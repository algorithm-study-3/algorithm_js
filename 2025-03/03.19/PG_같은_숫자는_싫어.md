# algorithm_js

# 📝 알고리즘 문제 풀이 - 2025-03-19

## 문제 📖

- **문제 링크:** [프로그래머스 - 같은 숫자는 싫어](https://school.programmers.co.kr/learn/courses/30/lessons/12906)

- **문제 유형:** 스택 / 큐

- **난이도:** Level 1

- **풀이 시간:** 9분

## ✏️ 문제 설명

## ✍ 접근 방식

### ✔️ 내 풀이 방식

**시간 복잡도:** O(N)

**공간 복잡도:** O(N)

**풀이 과정**

```
- 입력받은 배열의 첫 번째 값(arr[0])을 결과 배열(answer)에 넣고 결과 배열(answer)에 대한 인덱스(idx)를 따로 관리
- 입력 받은 배열(arr)을 인덱스 1부터 순회하며, 해당 값이 결과 배열에 가장 최근에 넣은 값(answer[idx])과 일치하지 않는 경우에만 answer에 arr[i]를 push 해줌. idx도 하나 증가.
```

**채점 결과**

기본 테스트 케이스 통과 평균 (0.12ms, 33.5MB)

- 정확성: 71.9
- 효율성: 28.1
- 합계: 100.0 / 100.0

### ✔️ 다른 사람 풀이 방식

**시간 복잡도:** O(N)

**공간 복잡도:** O(N)

**풀이 과정**

```
- filter 메서드를 사용해 이전 값과 같이 않은 값들만 추출
```

**채점 결과**

기본 테스트 케이스 통과 평균 (0.05ms, 33.6MB)

- 정확성: 71.9
- 효율성: 28.1
- 합계: 100.0 / 100.0

## ❓ 두 방식의 차이

두 방식 모두 시간 복잡도가 O(N)으로 동일한데 왜 테스트케이스 평균 시간 차이가 나는 건지 알아봤다.

찾아보니 내장 메서드 filter를 사용하면 내부적으로 자바스크립트 엔진이 최적화를 하기 때문에 더 빠르게 동작한다고 한다.

filter를 사용하면 항상 새로운 배열을 만들기 때문에 메모리 사용량이 많을 순 있지만, 본 문제에서는 어차피 두 문제 모두 배열을 한 번만 생성하기 때문에 크게 메모리 사용량 차이는 없다.

또 큰 차이는 배열에 값을 넣는 과정에서 발생할 수 있다.

for문을 통해 push 하는 것은 배열 길이가 하나씩 증가하면서 동적으로 크기가 조정되기 때문에 메모리 재할당 발생 가능성이 있다. 즉, **배열 크기 조정 비용**이 발생할 수 있는 것임.

반면에, filter를 사용하면 물론 새로운 배열을 만들긴 하지만, 배열의 크기를 예상하고 한 번에 메모리를 할당하는 경우가 많다. 따라서 이전 방식보다는 시간이 덜 걸리는 것.

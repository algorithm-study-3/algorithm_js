# algorithm_js

# 📝 알고리즘 문제 풀이 - 2025-03-12

## 문제 📖

- **문제 링크:** [백준 - 가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053)

- **문제 유형:** DP, 이분 탐색

- **난이도:** 실버2

- **풀이 시간:** ⏳ 1H + a

## ✏️ 문제 설명

LIS는 Longest Increasing Subsequence의 약자로 `최장 증가 부분 수열`을 의미함.
본 문제는 하나의 수열에서 오름차순으로 증가하는 가장 긴 부분 수열의 길이를 찾는 것.

## ✍ 접근 방식

### ✔️ DP

**시간 복잡도:** O(N^2)

**공간 복잡도:** O(N)

**풀이 과정**

```
가장 먼저 생각한 방식은 1차원 DP였다. 완전 탐색으로 제일 쉽기 때문에!
근데 생각보다 조건문이 헷갈렸고, dp를 어떻게 갱신해줄지도 헷갈렸다.

우선 dp[i]는 A[i]를 마지막 값으로 가지고 있는 LIS 길이를 저장한 값으로 정의했다.

각 A[i]에 대하여, 그 이전 인덱스 값까지인 j만큼, 즉 이전 값인 A[j]만큼 순회하며 비교해주었다.
이렇게 이전 값까지 비교해주는 이유는 이전 값보다 현재 값이 클 경우 오름차순으로 증가하는 수열이 되므로, dp를 갱신해주기 위함이다.

만약, 이전 값보다 크고(A[i] > A[j]), 현재 j까지의 LIS 길이인 dp[j]가 임시로 저장하는 값인 count 값보다 클 경우(dp[j] > count), 현재 count 값을 dp[j]로 갱신해주어야 한다! 왜냐하면 현재 요소 기준으로 누적된 가장 큰 값을 사용해 LIS 길이를 늘려줘야 하기 때문! 즉, dp[j] > count 이걸 해주는 이유는 LIS의 길이를 항상 최대값으로 유지하기 위함이다.

마지막에 현재 dp[i] 값을 설정할 때는 count에 1을 더해서 dp[i]로 넣어주었다. 이때 초기에 count 값을 0으로 설정해두면, 첫 번째 요소를 지날 때 내부 for 문을 지나치고 dp[0]이 1로 설정된다. 이는 자기 자신도 수열의 길이에 포함해주기 위함이다!
```

### ✔️ 이분 탐색 + DP

**시간 복잡도:** O(NlogN)

**공간 복잡도:** O(N)

**풀이 과정**

```
이분 탐색을 사용하면 시간 복잡도가 줄어든다.
기존 DP와는 약간 다른 방식으로 가야한다. 결괏값도 새로운 배열에 대한 길이가 된다.
새로운 배열 B는 오름차순의 가장 긴 부분 수열을 담은 배열이다.

우선 첫 번째 값을 넣어두고 for문을 한 번 돌리는데, 이때 B의 마지막 값이 현재 넣어주고자 하는 값보다 작다면, 즉 현재 넣어주고자 하는 값이 더 크다면 그냥 바로 배열에 push 해준다.
근데 만약 그렇지 않는다면 이분 탐색을 사용해 적절한 위치 인덱스를 찾고, 해당 위치의 값을 업데이트해준다.

물론 출력해보면, 해당 인덱스를 교체하는 일이기 때문에 배열 자체는 완전한 오름차순 부분 배열이 되지 않을 수 있다. (실제로 출력해보니 그럼) 오름차순 자체는 맞는데 순서가 달라질 수는 있음.

예를 들어, 아래와 같은 예제가 있다고 치자.

6
10 20 30 15 40 20

위에서 직접 가장 긴 오름차순 부분 배열을 빼보면 {10, 20, 30, 40} 이다. 그러나 아래 결과는 {10, 15, 20, 40} 으로 나온다.

하지만 마지막 요소보다 더 작은 값이 나오면 배열 길이가 늘어나지 않기 때문에 결괏값에 지장을 주진 않는다. 즉, 이렇게 해도 가능한 이유는 LIS의 실제 부분 수열 내용 자체가 아니라, LIS의 길이를 구하는 데 중점을 뒀기 때문이 아닐까 싶다.!

[ 10 ]
[ 10, 20 ]

[ 10, 20 ]
[ 10, 20, 30 ]

[ 10, 20, 30 ]
[ 10, 15, 30 ]

[ 10, 15, 30 ]
[ 10, 15, 30, 40 ]

[ 10, 15, 30, 40 ]
[ 10, 15, 20, 40 ]
```

### ✔️ 각 방식별 메모리 및 시간 차이

|                | DP   | 이분탐색 + DP |
| -------------- | ---- | ------------- |
| **메모리(KB)** | 9660 | 9436          |
| **시간(ms)**   | 156  | 96            |

- 이분 탐색 방식이 기존 DP 방식보다 시간적으로 더 효율적이라는 것을 보여줌.

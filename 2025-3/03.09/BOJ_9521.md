# algorithm_js

# 📝 알고리즘 문제 풀이 - 2025-03-09

## 문제 📖

- **문제 링크:** [백준 - LCS](https://www.acmicpc.net/problem/9251)

- **문제 유형:** DP

- **난이도:** 골드5

- **풀이 시간:** ⏳ 40M + a

## ✏️ 문제 설명

LCS란! Longest Common Subsequence 의 약자로 `최장 공통 부분 수열`을 의미함.
본 문제는 두 개의 문자열이 있을 때, 두 개 모두의 부분 수열이 되는 수열 중에 가장 긴 수열을 찾는 것!

## ✍ 접근 방식

본 문제는 각 알파벳이 최대 1000글자로 제한되어있기 때문에, 두 개의 문자열에 대해 시간 복잡도를 O(NM)으로 계산해보면 O(1000 \* 1000) = O(10^6) 이므로 시간 제한이 0.1초이기 때문에 충분히 가능하다고 판단했다.

실제로 1초에 10^8번 연산 가능하기 때문에, 10^6이면 0.01초로 계산 가능함.

### ✔️ 2차원 DP 배열 (초기 방식)

**시간 복잡도:** O(NM)

**공간 복잡도:** O(NM)

**풀이 과정**

```
우선 시간 복잡도가 O(NM) 까지는 가능하다고 판단해 2차원 DP 배열로 구현하였다.
이때 두 개의 문자열을 이중 for 문으로 순회하여, 다음과 같은 조건문을 실행해줬다.

1. str1[i - 1]과 str2[j - 1]이 같으면, dp[i][j] = dp[i - 1][j - 1] + 1 실행
2. 다르면, dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) 실행

이렇게 채우면 최장 공통 부분 수열의 길이가 이전 dp 값에 의해 누적 저장되어, 마지막 값인 dp[str1.length][str2.length]에 최종 결괏값이 저장됨.
```

### ✔️ 1차원 DP 배열

**시간 복잡도:** O(NM)

**공간 복잡도:** O(N)

**풀이 과정**

```
더 효율적인 방식 없나 싶어서 맞힌 사람 코드들 찾아보니, 1차원 DP 배열로 구현한 사람의 코드가 메모리도 절반 이하에 시간도 훨씬 단축되어 있었다.

이 방식은 dp를 1차원으로 구현하는 대신, 이전 dp 값을 계속 저장해두어야 한다.

만약, dp[j] = dp[j - 1] + 1 이렇게 하거나,
dp[j] = Math.max(dp[j], dp[j - 1] + 1) 이런식으로 갱신하게 된다면,
이전 값이 덮어씌워져서 더 큰 값이 사라질 수도 있다.

지금 주어진 예제에서는 오류가 안나지만 더 복잡한 예제일 경우 오류날 가능성이 있다.
(왜냐면 직접 해보니까 틀림. 뭔가 히든 케이스가 있나봄)
반례 케이스(질문 게시판): https://www.acmicpc.net/board/view/154500
```

### ✔️ 각 방식별 메모리 및 시간 차이

|                | 2차원 DP | 1차원 DP |
| -------------- | -------- | -------- |
| **메모리(KB)** | 10116    | 24672    |
| **시간(ms)**   | 200      | 168      |

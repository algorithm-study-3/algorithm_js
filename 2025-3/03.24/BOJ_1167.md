# algorithm_js

# 📝 알고리즘 문제 풀이 - 2025-03-24

## 문제 📖

- **문제 링크:** [백준 - 트리의 지름](https://www.acmicpc.net/problem/1167)

- **문제 유형:** 트리, DFS, 그래프 탐색

- **난이도:** 골드2

- **풀이 시간:** 40분 + a

## ✏️ 문제 설명

## ✍ 접근 방식

### ✔️ 내 풀이

**시간 복잡도:** O(V+E)

**공간 복잡도:** O(V+E)

**풀이 과정**

```
어떤 방식으로 트리를 관리할지 고민하다가 우선 이중 Map 객체를 사용해 각 연결된 정점과 그 간선의 가중치를 저장하도록 했다.
따라서 이중 Map으로 구성된 tree는 최대 V개의 노드와 E개의 간선을 저장하기 때문에 공간 복잡도가 O(V+E)가 된다.

그리고 깊이 우선 탐색(dfs)로 재귀를 사용해 연결된 정점들에 대한 가중치를 하나씩 더해주며 더 큰 값을 갱신해주는 식으로 했다.

첫 번째 dfs가 호출될 때는, 시작하는 노드와 부모 노드, 가중치 값을 각각 1, -1, 0으로 설정했다.
부모 노드는 아직 정해지지 않았기 때문에 초깃값으로 -1로 두었고, 1은 임의로 시작하는 노드를 설정한 것이다.

그리고 tree를 순회하여 현재 노드(key)에 대하여 Map으로 저장된 value 값들인 neighbor(연결된 정점), weight(가중치)를 하나씩 순회하였다.
이때 tree.get(node).forEach나 for..of 둘 다 순회 가능하다. 여기서 순회해주는 부분은 그 현재 노드(key)에 대한 value도 Map으로 되어있기 때문에 그 내부 Map 부분을 순회해주는 것이다. 즉, 현재 노드(key)에 대한 모든 연결된 정점(neighbor)과 가중치(weight)를 확인하는 것.

순회할 때 우선 부모 노드와 현재 neighbor가 같지 않은지 확인해야 한다. 만약 같은 경우에는 이미 탐색한 정점을 다시 돌아가는 것이라 사이클이 형성되기 때문에 최대 거리 합산에 중복이 생긴다.

부모 노드와 연결된 정점(neighbor)가 같지 않은 경우에 dfs를 재귀호출 해주면 된다.
이때 반환 값은 현재까지 이동한 정점, 즉 farthestNode와 그 정점까지 간 거리 maxDist를 반환해주면 된다.
이 재귀를 통해 반환된 값 newMaxDist와 maxDist와 비교하여 더 큰 값을 현재 값으로 갱신해주고, farthestNode도 갱신해준다.

두 번째 dfs를 호출해줄 때는 해당 farthestNodeA 노드에서 가장 먼 노드의 누적 가중치, 즉 트리의 지름을 반환받으면 된다.
```

## ❓ dfs를 2번 호출하는 이유

첫 번재 dfs에서 구한 `treeDiameter`를 바로 사용할 수 없는 이유는 **트리의 지름을 정확히 찾기 위해서 두 번의 DFS가 필요하기 때문**이다.

쉽게 말해 핵심은 다음과 같다.

```
임의의 노드에서 가장 먼 노드(A)는 항상 트리의 지름을 이루는 두 끝점 중 하나이다.
```

즉, `farthestNodeA`는 트리의 지름을 이루는 두 끝점 중 적어도 하나와 일치한다.
그렇기 때문에 우리가 첫 번째 dfs에서 `farthestNodeA`를 찾고 그 노드에서 다시 dfs를 했을 때 트리의 지름을 구할 수 있는 것이다.

그렇다면 왜 첫 번째 dfs에서 구한 farthestNodeA가 반드시 지름의 한 끝점이 되는가?

이걸 증명해보자.

### 1️⃣ 트리의 지름 정의

트리의 지름은 트리에서 두 정점 사이의 최장 경로를 의미한다.
만약 두 정점이 x, y라고 했을 때 우리의 목표는 dist(x, y)를 찾는 것이다.

### 2️⃣ 임의의 노드에서 dfs를 수행하면 가장 먼 노드(A)는 지름(x, y) 끝점 중 하나이다.

아무 노드에서나 dfs를 하면, 현재 노드에서 가장 먼 노드 A를 찾게 된다.
이제 A가 지름을 이루는 두 끝점(x, y) 중 하나와 반드시 일치한다는 것을 증명할 것이다.

✏️ **증명**

1. 반대로 A가 (x, y)와 관계 없는 지점이라면?

   - 즉, A가 지름(x, y) 상에 있지 않다면,
     A에서 더 먼 노드 B가 존재해야 함. (A에서 dfs를 하면 B가 나올 것임)

   - 하지만 A에서 dfs를 수행했을 때 B를 찾으면,
     이 경로는 기존의 지름(x, y)보다 길어야 함.

   - 즉 기존의 (x, y)가 지름이 아니라, 새로운 (A, B)가 지름이 되어야 함.

   - 기존 (x, y)가 지름이라고 가정했는데, (A, B)라는 더 긴 지름이 나왔으므로 모순 발생!

2. 즉, dfs에서 찾은 A는 (x, y) 중 하나와 반드시 일치한다.

   - 따라서, A에서 다시 dfs를 수행한다면 y를 찾을 수 있고, 이때 거리가 트리의 지름이 된다.

## 결과값 정리

```
[입력]
5
1 3 2 -1
2 4 4 -1
3 1 2 4 3 -1
4 2 4 3 3 5 6 -1
5 4 6 -1

[tree 구조]
Map(5) {
  1 => Map(1) { 3 => 2 },
  3 => Map(2) { 1 => 2, 4 => 3 },
  2 => Map(1) { 4 => 4 },
  4 => Map(3) { 2 => 4, 3 => 3, 5 => 6 },
  5 => Map(1) { 4 => 6 }
}

[출력]
11
```

## 그래프 데이터 구조 정리

| 방법                        | 장점                         | 단점                                  | 사용                                      |
| --------------------------- | ---------------------------- | ------------------------------------- | ----------------------------------------- |
| **인접 리스트 (Map/배열)**  | 특정 정점의 간선 조회 `O(1)` | 간선 순회 시 `O(N)` 필요              | **트리 문제에서 가장 일반적**             |
| **Edge List (간선 리스트)** | 간선 정렬/순회 쉬움          | 특정 노드의 연결 확인 어려움 (`O(N)`) | **Kruskal 알고리즘 같은 경우**            |
| **인접 행렬 (2D 배열)**     | `O(1)`로 연결 여부 확인      | 메모리 낭비 (`O(N^2)`)                | **노드 개수가 적고, 연결 확인이 많을 때** |
